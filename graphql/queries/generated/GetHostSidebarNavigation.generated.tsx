import * as Types from '../../schema/graphql';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  Cursor: { input: any; output: any; }
  JSON: { input: any; output: any; }
  Time: { input: any; output: any; }
  Upload: { input: any; output: any; }
};

export type Bookmark = Node & {
  __typename?: 'Bookmark';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  post: Post;
  postID: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
  user: User;
  userID: Scalars['ID']['output'];
};

/**
 * BookmarkWhereInput is used for filtering Bookmark objects.
 * Input was generated by ent.
 */
export type BookmarkWhereInput = {
  and?: InputMaybe<Array<BookmarkWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<BookmarkWhereInput>;
  or?: InputMaybe<Array<BookmarkWhereInput>>;
  /** post_id field predicates */
  postID?: InputMaybe<Scalars['ID']['input']>;
  postIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  postIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  postIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type Comment = Node & {
  __typename?: 'Comment';
  author: User;
  authorID: Scalars['ID']['output'];
  childrenComment?: Maybe<Array<Comment>>;
  community: Community;
  communityID: Scalars['ID']['output'];
  content: Scalars['String']['output'];
  createdAt: Scalars['Time']['output'];
  hasDeleted: Scalars['Boolean']['output'];
  hasUpdated: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  likes?: Maybe<Array<CommentLike>>;
  media?: Maybe<Media>;
  mediaID?: Maybe<Scalars['ID']['output']>;
  parentComment?: Maybe<Comment>;
  parentCommentID?: Maybe<Scalars['ID']['output']>;
  post: Post;
  postID: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
};

export type CommentLike = Node & {
  __typename?: 'CommentLike';
  comment: Comment;
  commentID: Scalars['ID']['output'];
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
  user: User;
  userID: Scalars['ID']['output'];
};

/**
 * CommentLikeWhereInput is used for filtering CommentLike objects.
 * Input was generated by ent.
 */
export type CommentLikeWhereInput = {
  and?: InputMaybe<Array<CommentLikeWhereInput>>;
  /** comment_id field predicates */
  commentID?: InputMaybe<Scalars['ID']['input']>;
  commentIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  commentIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  commentIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** comment edge predicates */
  hasComment?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommentWith?: InputMaybe<Array<CommentWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<CommentLikeWhereInput>;
  or?: InputMaybe<Array<CommentLikeWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/**
 * CommentWhereInput is used for filtering Comment objects.
 * Input was generated by ent.
 */
export type CommentWhereInput = {
  and?: InputMaybe<Array<CommentWhereInput>>;
  /** author_id field predicates */
  authorID?: InputMaybe<Scalars['ID']['input']>;
  authorIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  authorIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  authorIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** community_id field predicates */
  communityID?: InputMaybe<Scalars['ID']['input']>;
  communityIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  communityIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  communityIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** content field predicates */
  content?: InputMaybe<Scalars['String']['input']>;
  contentContains?: InputMaybe<Scalars['String']['input']>;
  contentContainsFold?: InputMaybe<Scalars['String']['input']>;
  contentEqualFold?: InputMaybe<Scalars['String']['input']>;
  contentGT?: InputMaybe<Scalars['String']['input']>;
  contentGTE?: InputMaybe<Scalars['String']['input']>;
  contentHasPrefix?: InputMaybe<Scalars['String']['input']>;
  contentHasSuffix?: InputMaybe<Scalars['String']['input']>;
  contentIn?: InputMaybe<Array<Scalars['String']['input']>>;
  contentLT?: InputMaybe<Scalars['String']['input']>;
  contentLTE?: InputMaybe<Scalars['String']['input']>;
  contentNEQ?: InputMaybe<Scalars['String']['input']>;
  contentNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** author edge predicates */
  hasAuthor?: InputMaybe<Scalars['Boolean']['input']>;
  hasAuthorWith?: InputMaybe<Array<UserWhereInput>>;
  /** children_comment edge predicates */
  hasChildrenComment?: InputMaybe<Scalars['Boolean']['input']>;
  hasChildrenCommentWith?: InputMaybe<Array<CommentWhereInput>>;
  /** community edge predicates */
  hasCommunity?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommunityWith?: InputMaybe<Array<CommunityWhereInput>>;
  /** has_deleted field predicates */
  hasDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  hasDeletedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** likes edge predicates */
  hasLikes?: InputMaybe<Scalars['Boolean']['input']>;
  hasLikesWith?: InputMaybe<Array<CommentLikeWhereInput>>;
  /** media edge predicates */
  hasMedia?: InputMaybe<Scalars['Boolean']['input']>;
  hasMediaWith?: InputMaybe<Array<MediaWhereInput>>;
  /** parent_comment edge predicates */
  hasParentComment?: InputMaybe<Scalars['Boolean']['input']>;
  hasParentCommentWith?: InputMaybe<Array<CommentWhereInput>>;
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** has_updated field predicates */
  hasUpdated?: InputMaybe<Scalars['Boolean']['input']>;
  hasUpdatedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** media_id field predicates */
  mediaID?: InputMaybe<Scalars['ID']['input']>;
  mediaIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  mediaIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  mediaIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  mediaIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  mediaIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<CommentWhereInput>;
  or?: InputMaybe<Array<CommentWhereInput>>;
  /** parent_comment_id field predicates */
  parentCommentID?: InputMaybe<Scalars['ID']['input']>;
  parentCommentIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  parentCommentIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  parentCommentIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  parentCommentIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  parentCommentIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** post_id field predicates */
  postID?: InputMaybe<Scalars['ID']['input']>;
  postIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  postIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  postIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type Community = Node & {
  __typename?: 'Community';
  banner?: Maybe<Media>;
  bannerID?: Maybe<Scalars['ID']['output']>;
  bans?: Maybe<Array<CommunityUserBan>>;
  comments?: Maybe<Array<Comment>>;
  communityHasBanned: Scalars['Boolean']['output'];
  communityInfo?: Maybe<Array<ProfileTableInfoItem>>;
  contacts?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Time']['output'];
  description?: Maybe<Scalars['String']['output']>;
  followers?: Maybe<Array<CommunityFollow>>;
  id: Scalars['ID']['output'];
  logo?: Maybe<Media>;
  logoID?: Maybe<Scalars['ID']['output']>;
  moderators?: Maybe<Array<CommunityModerator>>;
  mutes?: Maybe<Array<CommunityUserMute>>;
  owner: User;
  ownerID: Scalars['ID']['output'];
  posts?: Maybe<Array<Post>>;
  roles?: Maybe<Array<Role>>;
  rules?: Maybe<Array<CommunityRule>>;
  slug: Scalars['String']['output'];
  title: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
};

export type CommunityFollow = Node & {
  __typename?: 'CommunityFollow';
  community: Community;
  communityID: Scalars['ID']['output'];
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
  user: User;
  userID: Scalars['ID']['output'];
};

/**
 * CommunityFollowWhereInput is used for filtering CommunityFollow objects.
 * Input was generated by ent.
 */
export type CommunityFollowWhereInput = {
  and?: InputMaybe<Array<CommunityFollowWhereInput>>;
  /** community_id field predicates */
  communityID?: InputMaybe<Scalars['ID']['input']>;
  communityIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  communityIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  communityIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** community edge predicates */
  hasCommunity?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommunityWith?: InputMaybe<Array<CommunityWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<CommunityFollowWhereInput>;
  or?: InputMaybe<Array<CommunityFollowWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type CommunityModerator = Node & {
  __typename?: 'CommunityModerator';
  community: Community;
  communityID: Scalars['ID']['output'];
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
  user: User;
  userID: Scalars['ID']['output'];
};

/**
 * CommunityModeratorWhereInput is used for filtering CommunityModerator objects.
 * Input was generated by ent.
 */
export type CommunityModeratorWhereInput = {
  and?: InputMaybe<Array<CommunityModeratorWhereInput>>;
  /** community_id field predicates */
  communityID?: InputMaybe<Scalars['ID']['input']>;
  communityIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  communityIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  communityIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** community edge predicates */
  hasCommunity?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommunityWith?: InputMaybe<Array<CommunityWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<CommunityModeratorWhereInput>;
  or?: InputMaybe<Array<CommunityModeratorWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type CommunityPermissions = {
  __typename?: 'CommunityPermissions';
  communityDeleteComments: Scalars['Boolean']['output'];
  communityDeletePost: Scalars['Boolean']['output'];
  communityOwner: Scalars['Boolean']['output'];
  communityRemovePostFromPublication: Scalars['Boolean']['output'];
  communityRolesManagement: Scalars['Boolean']['output'];
  communityUserBan: Scalars['Boolean']['output'];
  communityUserHasBanned: Scalars['Boolean']['output'];
  communityUserHasMuted: Scalars['Boolean']['output'];
  communityUserMute: Scalars['Boolean']['output'];
  hostOwner: Scalars['Boolean']['output'];
};

export type CommunityRule = Node & {
  __typename?: 'CommunityRule';
  community?: Maybe<Community>;
  communityDescriptionRule?: Maybe<Scalars['String']['output']>;
  communityNameRule?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  ruleID?: Maybe<Scalars['ID']['output']>;
  updatedAt: Scalars['Time']['output'];
};

/**
 * CommunityRuleWhereInput is used for filtering CommunityRule objects.
 * Input was generated by ent.
 */
export type CommunityRuleWhereInput = {
  and?: InputMaybe<Array<CommunityRuleWhereInput>>;
  /** community_description_rule field predicates */
  communityDescriptionRule?: InputMaybe<Scalars['String']['input']>;
  communityDescriptionRuleContains?: InputMaybe<Scalars['String']['input']>;
  communityDescriptionRuleContainsFold?: InputMaybe<Scalars['String']['input']>;
  communityDescriptionRuleEqualFold?: InputMaybe<Scalars['String']['input']>;
  communityDescriptionRuleGT?: InputMaybe<Scalars['String']['input']>;
  communityDescriptionRuleGTE?: InputMaybe<Scalars['String']['input']>;
  communityDescriptionRuleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  communityDescriptionRuleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  communityDescriptionRuleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  communityDescriptionRuleIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  communityDescriptionRuleLT?: InputMaybe<Scalars['String']['input']>;
  communityDescriptionRuleLTE?: InputMaybe<Scalars['String']['input']>;
  communityDescriptionRuleNEQ?: InputMaybe<Scalars['String']['input']>;
  communityDescriptionRuleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  communityDescriptionRuleNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** community_name_rule field predicates */
  communityNameRule?: InputMaybe<Scalars['String']['input']>;
  communityNameRuleContains?: InputMaybe<Scalars['String']['input']>;
  communityNameRuleContainsFold?: InputMaybe<Scalars['String']['input']>;
  communityNameRuleEqualFold?: InputMaybe<Scalars['String']['input']>;
  communityNameRuleGT?: InputMaybe<Scalars['String']['input']>;
  communityNameRuleGTE?: InputMaybe<Scalars['String']['input']>;
  communityNameRuleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  communityNameRuleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  communityNameRuleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  communityNameRuleIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  communityNameRuleLT?: InputMaybe<Scalars['String']['input']>;
  communityNameRuleLTE?: InputMaybe<Scalars['String']['input']>;
  communityNameRuleNEQ?: InputMaybe<Scalars['String']['input']>;
  communityNameRuleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  communityNameRuleNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** community edge predicates */
  hasCommunity?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommunityWith?: InputMaybe<Array<CommunityWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<CommunityRuleWhereInput>;
  or?: InputMaybe<Array<CommunityRuleWhereInput>>;
  /** rule_id field predicates */
  ruleID?: InputMaybe<Scalars['ID']['input']>;
  ruleIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  ruleIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  ruleIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  ruleIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  ruleIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type CommunityUserBan = Node & {
  __typename?: 'CommunityUserBan';
  community: Community;
  communityID: Scalars['ID']['output'];
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
  user: User;
  userID: Scalars['ID']['output'];
};

/**
 * CommunityUserBanWhereInput is used for filtering CommunityUserBan objects.
 * Input was generated by ent.
 */
export type CommunityUserBanWhereInput = {
  and?: InputMaybe<Array<CommunityUserBanWhereInput>>;
  /** community_id field predicates */
  communityID?: InputMaybe<Scalars['ID']['input']>;
  communityIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  communityIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  communityIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** community edge predicates */
  hasCommunity?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommunityWith?: InputMaybe<Array<CommunityWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<CommunityUserBanWhereInput>;
  or?: InputMaybe<Array<CommunityUserBanWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type CommunityUserMute = Node & {
  __typename?: 'CommunityUserMute';
  community: Community;
  communityID: Scalars['ID']['output'];
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
  user: User;
  userID: Scalars['ID']['output'];
};

/**
 * CommunityUserMuteWhereInput is used for filtering CommunityUserMute objects.
 * Input was generated by ent.
 */
export type CommunityUserMuteWhereInput = {
  and?: InputMaybe<Array<CommunityUserMuteWhereInput>>;
  /** community_id field predicates */
  communityID?: InputMaybe<Scalars['ID']['input']>;
  communityIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  communityIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  communityIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** community edge predicates */
  hasCommunity?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommunityWith?: InputMaybe<Array<CommunityWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<CommunityUserMuteWhereInput>;
  or?: InputMaybe<Array<CommunityUserMuteWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/**
 * CommunityWhereInput is used for filtering Community objects.
 * Input was generated by ent.
 */
export type CommunityWhereInput = {
  and?: InputMaybe<Array<CommunityWhereInput>>;
  /** banner_id field predicates */
  bannerID?: InputMaybe<Scalars['ID']['input']>;
  bannerIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  bannerIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  bannerIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  bannerIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  bannerIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** community_has_banned field predicates */
  communityHasBanned?: InputMaybe<Scalars['Boolean']['input']>;
  communityHasBannedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** contacts field predicates */
  contacts?: InputMaybe<Scalars['String']['input']>;
  contactsContains?: InputMaybe<Scalars['String']['input']>;
  contactsContainsFold?: InputMaybe<Scalars['String']['input']>;
  contactsEqualFold?: InputMaybe<Scalars['String']['input']>;
  contactsGT?: InputMaybe<Scalars['String']['input']>;
  contactsGTE?: InputMaybe<Scalars['String']['input']>;
  contactsHasPrefix?: InputMaybe<Scalars['String']['input']>;
  contactsHasSuffix?: InputMaybe<Scalars['String']['input']>;
  contactsIn?: InputMaybe<Array<Scalars['String']['input']>>;
  contactsIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  contactsLT?: InputMaybe<Scalars['String']['input']>;
  contactsLTE?: InputMaybe<Scalars['String']['input']>;
  contactsNEQ?: InputMaybe<Scalars['String']['input']>;
  contactsNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  contactsNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** banner edge predicates */
  hasBanner?: InputMaybe<Scalars['Boolean']['input']>;
  hasBannerWith?: InputMaybe<Array<MediaWhereInput>>;
  /** bans edge predicates */
  hasBans?: InputMaybe<Scalars['Boolean']['input']>;
  hasBansWith?: InputMaybe<Array<CommunityUserBanWhereInput>>;
  /** comments edge predicates */
  hasComments?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommentsWith?: InputMaybe<Array<CommentWhereInput>>;
  /** community_info edge predicates */
  hasCommunityInfo?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommunityInfoWith?: InputMaybe<Array<ProfileTableInfoItemWhereInput>>;
  /** followers edge predicates */
  hasFollowers?: InputMaybe<Scalars['Boolean']['input']>;
  hasFollowersWith?: InputMaybe<Array<CommunityFollowWhereInput>>;
  /** logo edge predicates */
  hasLogo?: InputMaybe<Scalars['Boolean']['input']>;
  hasLogoWith?: InputMaybe<Array<MediaWhereInput>>;
  /** moderators edge predicates */
  hasModerators?: InputMaybe<Scalars['Boolean']['input']>;
  hasModeratorsWith?: InputMaybe<Array<CommunityModeratorWhereInput>>;
  /** mutes edge predicates */
  hasMutes?: InputMaybe<Scalars['Boolean']['input']>;
  hasMutesWith?: InputMaybe<Array<CommunityUserMuteWhereInput>>;
  /** owner edge predicates */
  hasOwner?: InputMaybe<Scalars['Boolean']['input']>;
  hasOwnerWith?: InputMaybe<Array<UserWhereInput>>;
  /** posts edge predicates */
  hasPosts?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostsWith?: InputMaybe<Array<PostWhereInput>>;
  /** roles edge predicates */
  hasRoles?: InputMaybe<Scalars['Boolean']['input']>;
  hasRolesWith?: InputMaybe<Array<RoleWhereInput>>;
  /** rules edge predicates */
  hasRules?: InputMaybe<Scalars['Boolean']['input']>;
  hasRulesWith?: InputMaybe<Array<CommunityRuleWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** logo_id field predicates */
  logoID?: InputMaybe<Scalars['ID']['input']>;
  logoIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  logoIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  logoIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  logoIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  logoIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<CommunityWhereInput>;
  or?: InputMaybe<Array<CommunityWhereInput>>;
  /** owner_id field predicates */
  ownerID?: InputMaybe<Scalars['ID']['input']>;
  ownerIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  ownerIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  ownerIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** slug field predicates */
  slug?: InputMaybe<Scalars['String']['input']>;
  slugContains?: InputMaybe<Scalars['String']['input']>;
  slugContainsFold?: InputMaybe<Scalars['String']['input']>;
  slugEqualFold?: InputMaybe<Scalars['String']['input']>;
  slugGT?: InputMaybe<Scalars['String']['input']>;
  slugGTE?: InputMaybe<Scalars['String']['input']>;
  slugHasPrefix?: InputMaybe<Scalars['String']['input']>;
  slugHasSuffix?: InputMaybe<Scalars['String']['input']>;
  slugIn?: InputMaybe<Array<Scalars['String']['input']>>;
  slugLT?: InputMaybe<Scalars['String']['input']>;
  slugLTE?: InputMaybe<Scalars['String']['input']>;
  slugNEQ?: InputMaybe<Scalars['String']['input']>;
  slugNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type CreateCommunityInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  ownerID: Scalars['ID']['input'];
  slug: Scalars['String']['input'];
  title: Scalars['String']['input'];
};

export type CreatePostInput = {
  authorID: Scalars['ID']['input'];
  communityID: Scalars['ID']['input'];
  content: Scalars['JSON']['input'];
  heroImageID?: InputMaybe<Scalars['ID']['input']>;
  publishedAt?: InputMaybe<Scalars['Time']['input']>;
  status?: InputMaybe<PostStatus>;
  title: Scalars['String']['input'];
};

export type EmailVerification = Node & {
  __typename?: 'EmailVerification';
  createdAt: Scalars['Time']['output'];
  expiresAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  token: Scalars['String']['output'];
  user?: Maybe<User>;
};

/**
 * EmailVerificationWhereInput is used for filtering EmailVerification objects.
 * Input was generated by ent.
 */
export type EmailVerificationWhereInput = {
  and?: InputMaybe<Array<EmailVerificationWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** expires_at field predicates */
  expiresAt?: InputMaybe<Scalars['Time']['input']>;
  expiresAtGT?: InputMaybe<Scalars['Time']['input']>;
  expiresAtGTE?: InputMaybe<Scalars['Time']['input']>;
  expiresAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  expiresAtLT?: InputMaybe<Scalars['Time']['input']>;
  expiresAtLTE?: InputMaybe<Scalars['Time']['input']>;
  expiresAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  expiresAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<EmailVerificationWhereInput>;
  or?: InputMaybe<Array<EmailVerificationWhereInput>>;
  /** token field predicates */
  token?: InputMaybe<Scalars['String']['input']>;
  tokenContains?: InputMaybe<Scalars['String']['input']>;
  tokenContainsFold?: InputMaybe<Scalars['String']['input']>;
  tokenEqualFold?: InputMaybe<Scalars['String']['input']>;
  tokenGT?: InputMaybe<Scalars['String']['input']>;
  tokenGTE?: InputMaybe<Scalars['String']['input']>;
  tokenHasPrefix?: InputMaybe<Scalars['String']['input']>;
  tokenHasSuffix?: InputMaybe<Scalars['String']['input']>;
  tokenIn?: InputMaybe<Array<Scalars['String']['input']>>;
  tokenLT?: InputMaybe<Scalars['String']['input']>;
  tokenLTE?: InputMaybe<Scalars['String']['input']>;
  tokenNEQ?: InputMaybe<Scalars['String']['input']>;
  tokenNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type Host = Node & {
  __typename?: 'Host';
  authBanner?: Maybe<Media>;
  authBannerID?: Maybe<Scalars['ID']['output']>;
  banner?: Maybe<Media>;
  bannerID?: Maybe<Scalars['ID']['output']>;
  contacts?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Time']['output'];
  description?: Maybe<Scalars['String']['output']>;
  firstSettings: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  logo?: Maybe<Media>;
  logoID?: Maybe<Scalars['ID']['output']>;
  owner?: Maybe<User>;
  ownerID?: Maybe<Scalars['ID']['output']>;
  rules?: Maybe<Array<HostRule>>;
  slogan?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Time']['output'];
};

export type HostCommunityBan = Node & {
  __typename?: 'HostCommunityBan';
  community: Community;
  communityID: Scalars['ID']['output'];
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
};

/**
 * HostCommunityBanWhereInput is used for filtering HostCommunityBan objects.
 * Input was generated by ent.
 */
export type HostCommunityBanWhereInput = {
  and?: InputMaybe<Array<HostCommunityBanWhereInput>>;
  /** community_id field predicates */
  communityID?: InputMaybe<Scalars['ID']['input']>;
  communityIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  communityIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  communityIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** community edge predicates */
  hasCommunity?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommunityWith?: InputMaybe<Array<CommunityWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<HostCommunityBanWhereInput>;
  or?: InputMaybe<Array<HostCommunityBanWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type HostCommunityMute = Node & {
  __typename?: 'HostCommunityMute';
  community: Community;
  communityID: Scalars['ID']['output'];
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
};

/**
 * HostCommunityMuteWhereInput is used for filtering HostCommunityMute objects.
 * Input was generated by ent.
 */
export type HostCommunityMuteWhereInput = {
  and?: InputMaybe<Array<HostCommunityMuteWhereInput>>;
  /** community_id field predicates */
  communityID?: InputMaybe<Scalars['ID']['input']>;
  communityIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  communityIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  communityIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** community edge predicates */
  hasCommunity?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommunityWith?: InputMaybe<Array<CommunityWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<HostCommunityMuteWhereInput>;
  or?: InputMaybe<Array<HostCommunityMuteWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type HostRole = Node & {
  __typename?: 'HostRole';
  badge?: Maybe<Media>;
  badgeID?: Maybe<Scalars['ID']['output']>;
  color?: Maybe<Scalars['String']['output']>;
  communityRolesManagement: Scalars['Boolean']['output'];
  createdAt: Scalars['Time']['output'];
  hostCommunityDeleteComments: Scalars['Boolean']['output'];
  hostCommunityDeletePost: Scalars['Boolean']['output'];
  hostCommunityRemovePostFromPublication: Scalars['Boolean']['output'];
  hostUserBan: Scalars['Boolean']['output'];
  hostUserMute: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  title: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
  users?: Maybe<Array<User>>;
};

/**
 * HostRoleWhereInput is used for filtering HostRole objects.
 * Input was generated by ent.
 */
export type HostRoleWhereInput = {
  and?: InputMaybe<Array<HostRoleWhereInput>>;
  /** badge_id field predicates */
  badgeID?: InputMaybe<Scalars['ID']['input']>;
  badgeIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  badgeIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  badgeIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  badgeIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  badgeIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** color field predicates */
  color?: InputMaybe<Scalars['String']['input']>;
  colorContains?: InputMaybe<Scalars['String']['input']>;
  colorContainsFold?: InputMaybe<Scalars['String']['input']>;
  colorEqualFold?: InputMaybe<Scalars['String']['input']>;
  colorGT?: InputMaybe<Scalars['String']['input']>;
  colorGTE?: InputMaybe<Scalars['String']['input']>;
  colorHasPrefix?: InputMaybe<Scalars['String']['input']>;
  colorHasSuffix?: InputMaybe<Scalars['String']['input']>;
  colorIn?: InputMaybe<Array<Scalars['String']['input']>>;
  colorIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  colorLT?: InputMaybe<Scalars['String']['input']>;
  colorLTE?: InputMaybe<Scalars['String']['input']>;
  colorNEQ?: InputMaybe<Scalars['String']['input']>;
  colorNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  colorNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** community_roles_management field predicates */
  communityRolesManagement?: InputMaybe<Scalars['Boolean']['input']>;
  communityRolesManagementNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** badge edge predicates */
  hasBadge?: InputMaybe<Scalars['Boolean']['input']>;
  hasBadgeWith?: InputMaybe<Array<MediaWhereInput>>;
  /** users edge predicates */
  hasUsers?: InputMaybe<Scalars['Boolean']['input']>;
  hasUsersWith?: InputMaybe<Array<UserWhereInput>>;
  /** host_community_delete_comments field predicates */
  hostCommunityDeleteComments?: InputMaybe<Scalars['Boolean']['input']>;
  hostCommunityDeleteCommentsNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** host_community_delete_post field predicates */
  hostCommunityDeletePost?: InputMaybe<Scalars['Boolean']['input']>;
  hostCommunityDeletePostNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** host_community_remove_post_from_publication field predicates */
  hostCommunityRemovePostFromPublication?: InputMaybe<Scalars['Boolean']['input']>;
  hostCommunityRemovePostFromPublicationNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** host_user_ban field predicates */
  hostUserBan?: InputMaybe<Scalars['Boolean']['input']>;
  hostUserBanNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** host_user_mute field predicates */
  hostUserMute?: InputMaybe<Scalars['Boolean']['input']>;
  hostUserMuteNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<HostRoleWhereInput>;
  or?: InputMaybe<Array<HostRoleWhereInput>>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type HostRule = Node & {
  __typename?: 'HostRule';
  createdAt: Scalars['Time']['output'];
  descriptionRule?: Maybe<Scalars['String']['output']>;
  host?: Maybe<Host>;
  id: Scalars['ID']['output'];
  nameRule?: Maybe<Scalars['String']['output']>;
  ruleID?: Maybe<Scalars['ID']['output']>;
  updatedAt: Scalars['Time']['output'];
};

/**
 * HostRuleWhereInput is used for filtering HostRule objects.
 * Input was generated by ent.
 */
export type HostRuleWhereInput = {
  and?: InputMaybe<Array<HostRuleWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** description_rule field predicates */
  descriptionRule?: InputMaybe<Scalars['String']['input']>;
  descriptionRuleContains?: InputMaybe<Scalars['String']['input']>;
  descriptionRuleContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionRuleEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionRuleGT?: InputMaybe<Scalars['String']['input']>;
  descriptionRuleGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionRuleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionRuleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionRuleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionRuleIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  descriptionRuleLT?: InputMaybe<Scalars['String']['input']>;
  descriptionRuleLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionRuleNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionRuleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionRuleNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** host edge predicates */
  hasHost?: InputMaybe<Scalars['Boolean']['input']>;
  hasHostWith?: InputMaybe<Array<HostWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name_rule field predicates */
  nameRule?: InputMaybe<Scalars['String']['input']>;
  nameRuleContains?: InputMaybe<Scalars['String']['input']>;
  nameRuleContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameRuleEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameRuleGT?: InputMaybe<Scalars['String']['input']>;
  nameRuleGTE?: InputMaybe<Scalars['String']['input']>;
  nameRuleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameRuleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameRuleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameRuleIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameRuleLT?: InputMaybe<Scalars['String']['input']>;
  nameRuleLTE?: InputMaybe<Scalars['String']['input']>;
  nameRuleNEQ?: InputMaybe<Scalars['String']['input']>;
  nameRuleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameRuleNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<HostRuleWhereInput>;
  or?: InputMaybe<Array<HostRuleWhereInput>>;
  /** rule_id field predicates */
  ruleID?: InputMaybe<Scalars['ID']['input']>;
  ruleIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  ruleIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  ruleIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  ruleIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  ruleIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type HostSidebarNavigation = Node & {
  __typename?: 'HostSidebarNavigation';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  items?: Maybe<Array<HostSidebarNavigationItem>>;
  updatedAt: Scalars['Time']['output'];
};

export type HostSidebarNavigationItem = Node & {
  __typename?: 'HostSidebarNavigationItem';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  post: Post;
  postID: Scalars['ID']['output'];
  sidebarNavigation: HostSidebarNavigation;
  sidebarNavigationID: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
};

/**
 * HostSidebarNavigationItemWhereInput is used for filtering HostSidebarNavigationItem objects.
 * Input was generated by ent.
 */
export type HostSidebarNavigationItemWhereInput = {
  and?: InputMaybe<Array<HostSidebarNavigationItemWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** sidebar_navigation edge predicates */
  hasSidebarNavigation?: InputMaybe<Scalars['Boolean']['input']>;
  hasSidebarNavigationWith?: InputMaybe<Array<HostSidebarNavigationWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<HostSidebarNavigationItemWhereInput>;
  or?: InputMaybe<Array<HostSidebarNavigationItemWhereInput>>;
  /** post_id field predicates */
  postID?: InputMaybe<Scalars['ID']['input']>;
  postIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  postIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  postIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** sidebar_navigation_id field predicates */
  sidebarNavigationID?: InputMaybe<Scalars['ID']['input']>;
  sidebarNavigationIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  sidebarNavigationIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  sidebarNavigationIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/**
 * HostSidebarNavigationWhereInput is used for filtering HostSidebarNavigation objects.
 * Input was generated by ent.
 */
export type HostSidebarNavigationWhereInput = {
  and?: InputMaybe<Array<HostSidebarNavigationWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** items edge predicates */
  hasItems?: InputMaybe<Scalars['Boolean']['input']>;
  hasItemsWith?: InputMaybe<Array<HostSidebarNavigationItemWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<HostSidebarNavigationWhereInput>;
  or?: InputMaybe<Array<HostSidebarNavigationWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type HostSocialNavigation = Node & {
  __typename?: 'HostSocialNavigation';
  createdAt: Scalars['Time']['output'];
  github?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  instagram?: Maybe<Scalars['String']['output']>;
  mastodon?: Maybe<Scalars['String']['output']>;
  site?: Maybe<Scalars['String']['output']>;
  telegram?: Maybe<Scalars['String']['output']>;
  twitter?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Time']['output'];
};

/**
 * HostSocialNavigationWhereInput is used for filtering HostSocialNavigation objects.
 * Input was generated by ent.
 */
export type HostSocialNavigationWhereInput = {
  and?: InputMaybe<Array<HostSocialNavigationWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** github field predicates */
  github?: InputMaybe<Scalars['String']['input']>;
  githubContains?: InputMaybe<Scalars['String']['input']>;
  githubContainsFold?: InputMaybe<Scalars['String']['input']>;
  githubEqualFold?: InputMaybe<Scalars['String']['input']>;
  githubGT?: InputMaybe<Scalars['String']['input']>;
  githubGTE?: InputMaybe<Scalars['String']['input']>;
  githubHasPrefix?: InputMaybe<Scalars['String']['input']>;
  githubHasSuffix?: InputMaybe<Scalars['String']['input']>;
  githubIn?: InputMaybe<Array<Scalars['String']['input']>>;
  githubIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  githubLT?: InputMaybe<Scalars['String']['input']>;
  githubLTE?: InputMaybe<Scalars['String']['input']>;
  githubNEQ?: InputMaybe<Scalars['String']['input']>;
  githubNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  githubNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** instagram field predicates */
  instagram?: InputMaybe<Scalars['String']['input']>;
  instagramContains?: InputMaybe<Scalars['String']['input']>;
  instagramContainsFold?: InputMaybe<Scalars['String']['input']>;
  instagramEqualFold?: InputMaybe<Scalars['String']['input']>;
  instagramGT?: InputMaybe<Scalars['String']['input']>;
  instagramGTE?: InputMaybe<Scalars['String']['input']>;
  instagramHasPrefix?: InputMaybe<Scalars['String']['input']>;
  instagramHasSuffix?: InputMaybe<Scalars['String']['input']>;
  instagramIn?: InputMaybe<Array<Scalars['String']['input']>>;
  instagramIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  instagramLT?: InputMaybe<Scalars['String']['input']>;
  instagramLTE?: InputMaybe<Scalars['String']['input']>;
  instagramNEQ?: InputMaybe<Scalars['String']['input']>;
  instagramNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  instagramNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** mastodon field predicates */
  mastodon?: InputMaybe<Scalars['String']['input']>;
  mastodonContains?: InputMaybe<Scalars['String']['input']>;
  mastodonContainsFold?: InputMaybe<Scalars['String']['input']>;
  mastodonEqualFold?: InputMaybe<Scalars['String']['input']>;
  mastodonGT?: InputMaybe<Scalars['String']['input']>;
  mastodonGTE?: InputMaybe<Scalars['String']['input']>;
  mastodonHasPrefix?: InputMaybe<Scalars['String']['input']>;
  mastodonHasSuffix?: InputMaybe<Scalars['String']['input']>;
  mastodonIn?: InputMaybe<Array<Scalars['String']['input']>>;
  mastodonIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  mastodonLT?: InputMaybe<Scalars['String']['input']>;
  mastodonLTE?: InputMaybe<Scalars['String']['input']>;
  mastodonNEQ?: InputMaybe<Scalars['String']['input']>;
  mastodonNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  mastodonNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<HostSocialNavigationWhereInput>;
  or?: InputMaybe<Array<HostSocialNavigationWhereInput>>;
  /** site field predicates */
  site?: InputMaybe<Scalars['String']['input']>;
  siteContains?: InputMaybe<Scalars['String']['input']>;
  siteContainsFold?: InputMaybe<Scalars['String']['input']>;
  siteEqualFold?: InputMaybe<Scalars['String']['input']>;
  siteGT?: InputMaybe<Scalars['String']['input']>;
  siteGTE?: InputMaybe<Scalars['String']['input']>;
  siteHasPrefix?: InputMaybe<Scalars['String']['input']>;
  siteHasSuffix?: InputMaybe<Scalars['String']['input']>;
  siteIn?: InputMaybe<Array<Scalars['String']['input']>>;
  siteIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  siteLT?: InputMaybe<Scalars['String']['input']>;
  siteLTE?: InputMaybe<Scalars['String']['input']>;
  siteNEQ?: InputMaybe<Scalars['String']['input']>;
  siteNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  siteNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** telegram field predicates */
  telegram?: InputMaybe<Scalars['String']['input']>;
  telegramContains?: InputMaybe<Scalars['String']['input']>;
  telegramContainsFold?: InputMaybe<Scalars['String']['input']>;
  telegramEqualFold?: InputMaybe<Scalars['String']['input']>;
  telegramGT?: InputMaybe<Scalars['String']['input']>;
  telegramGTE?: InputMaybe<Scalars['String']['input']>;
  telegramHasPrefix?: InputMaybe<Scalars['String']['input']>;
  telegramHasSuffix?: InputMaybe<Scalars['String']['input']>;
  telegramIn?: InputMaybe<Array<Scalars['String']['input']>>;
  telegramIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  telegramLT?: InputMaybe<Scalars['String']['input']>;
  telegramLTE?: InputMaybe<Scalars['String']['input']>;
  telegramNEQ?: InputMaybe<Scalars['String']['input']>;
  telegramNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  telegramNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** twitter field predicates */
  twitter?: InputMaybe<Scalars['String']['input']>;
  twitterContains?: InputMaybe<Scalars['String']['input']>;
  twitterContainsFold?: InputMaybe<Scalars['String']['input']>;
  twitterEqualFold?: InputMaybe<Scalars['String']['input']>;
  twitterGT?: InputMaybe<Scalars['String']['input']>;
  twitterGTE?: InputMaybe<Scalars['String']['input']>;
  twitterHasPrefix?: InputMaybe<Scalars['String']['input']>;
  twitterHasSuffix?: InputMaybe<Scalars['String']['input']>;
  twitterIn?: InputMaybe<Array<Scalars['String']['input']>>;
  twitterIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  twitterLT?: InputMaybe<Scalars['String']['input']>;
  twitterLTE?: InputMaybe<Scalars['String']['input']>;
  twitterNEQ?: InputMaybe<Scalars['String']['input']>;
  twitterNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  twitterNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type HostUserBan = Node & {
  __typename?: 'HostUserBan';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
  user: User;
};

/**
 * HostUserBanWhereInput is used for filtering HostUserBan objects.
 * Input was generated by ent.
 */
export type HostUserBanWhereInput = {
  and?: InputMaybe<Array<HostUserBanWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<HostUserBanWhereInput>;
  or?: InputMaybe<Array<HostUserBanWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type HostUserMute = Node & {
  __typename?: 'HostUserMute';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
  user: User;
};

/**
 * HostUserMuteWhereInput is used for filtering HostUserMute objects.
 * Input was generated by ent.
 */
export type HostUserMuteWhereInput = {
  and?: InputMaybe<Array<HostUserMuteWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<HostUserMuteWhereInput>;
  or?: InputMaybe<Array<HostUserMuteWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/**
 * HostWhereInput is used for filtering Host objects.
 * Input was generated by ent.
 */
export type HostWhereInput = {
  and?: InputMaybe<Array<HostWhereInput>>;
  /** auth_banner_id field predicates */
  authBannerID?: InputMaybe<Scalars['ID']['input']>;
  authBannerIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  authBannerIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  authBannerIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  authBannerIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  authBannerIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** banner_id field predicates */
  bannerID?: InputMaybe<Scalars['ID']['input']>;
  bannerIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  bannerIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  bannerIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  bannerIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  bannerIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** contacts field predicates */
  contacts?: InputMaybe<Scalars['String']['input']>;
  contactsContains?: InputMaybe<Scalars['String']['input']>;
  contactsContainsFold?: InputMaybe<Scalars['String']['input']>;
  contactsEqualFold?: InputMaybe<Scalars['String']['input']>;
  contactsGT?: InputMaybe<Scalars['String']['input']>;
  contactsGTE?: InputMaybe<Scalars['String']['input']>;
  contactsHasPrefix?: InputMaybe<Scalars['String']['input']>;
  contactsHasSuffix?: InputMaybe<Scalars['String']['input']>;
  contactsIn?: InputMaybe<Array<Scalars['String']['input']>>;
  contactsIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  contactsLT?: InputMaybe<Scalars['String']['input']>;
  contactsLTE?: InputMaybe<Scalars['String']['input']>;
  contactsNEQ?: InputMaybe<Scalars['String']['input']>;
  contactsNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  contactsNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** first_settings field predicates */
  firstSettings?: InputMaybe<Scalars['Boolean']['input']>;
  firstSettingsNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** auth_banner edge predicates */
  hasAuthBanner?: InputMaybe<Scalars['Boolean']['input']>;
  hasAuthBannerWith?: InputMaybe<Array<MediaWhereInput>>;
  /** banner edge predicates */
  hasBanner?: InputMaybe<Scalars['Boolean']['input']>;
  hasBannerWith?: InputMaybe<Array<MediaWhereInput>>;
  /** logo edge predicates */
  hasLogo?: InputMaybe<Scalars['Boolean']['input']>;
  hasLogoWith?: InputMaybe<Array<MediaWhereInput>>;
  /** owner edge predicates */
  hasOwner?: InputMaybe<Scalars['Boolean']['input']>;
  hasOwnerWith?: InputMaybe<Array<UserWhereInput>>;
  /** rules edge predicates */
  hasRules?: InputMaybe<Scalars['Boolean']['input']>;
  hasRulesWith?: InputMaybe<Array<HostRuleWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** logo_id field predicates */
  logoID?: InputMaybe<Scalars['ID']['input']>;
  logoIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  logoIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  logoIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  logoIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  logoIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<HostWhereInput>;
  or?: InputMaybe<Array<HostWhereInput>>;
  /** owner_id field predicates */
  ownerID?: InputMaybe<Scalars['ID']['input']>;
  ownerIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  ownerIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  ownerIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  ownerIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  ownerIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** slogan field predicates */
  slogan?: InputMaybe<Scalars['String']['input']>;
  sloganContains?: InputMaybe<Scalars['String']['input']>;
  sloganContainsFold?: InputMaybe<Scalars['String']['input']>;
  sloganEqualFold?: InputMaybe<Scalars['String']['input']>;
  sloganGT?: InputMaybe<Scalars['String']['input']>;
  sloganGTE?: InputMaybe<Scalars['String']['input']>;
  sloganHasPrefix?: InputMaybe<Scalars['String']['input']>;
  sloganHasSuffix?: InputMaybe<Scalars['String']['input']>;
  sloganIn?: InputMaybe<Array<Scalars['String']['input']>>;
  sloganIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  sloganLT?: InputMaybe<Scalars['String']['input']>;
  sloganLTE?: InputMaybe<Scalars['String']['input']>;
  sloganNEQ?: InputMaybe<Scalars['String']['input']>;
  sloganNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  sloganNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type LoginUserInput = {
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};

export type LoginUserResponse = {
  __typename?: 'LoginUserResponse';
  accessToken: Scalars['String']['output'];
  refreshToken: Scalars['String']['output'];
  user: UserResponse;
};

export type LogoutUserResponse = {
  __typename?: 'LogoutUserResponse';
  message: Scalars['String']['output'];
};

export type Media = Node & {
  __typename?: 'Media';
  alt?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Time']['output'];
  filename?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  thumbnailURL?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Time']['output'];
  url?: Maybe<Scalars['String']['output']>;
};

/**
 * MediaWhereInput is used for filtering Media objects.
 * Input was generated by ent.
 */
export type MediaWhereInput = {
  /** alt field predicates */
  alt?: InputMaybe<Scalars['String']['input']>;
  altContains?: InputMaybe<Scalars['String']['input']>;
  altContainsFold?: InputMaybe<Scalars['String']['input']>;
  altEqualFold?: InputMaybe<Scalars['String']['input']>;
  altGT?: InputMaybe<Scalars['String']['input']>;
  altGTE?: InputMaybe<Scalars['String']['input']>;
  altHasPrefix?: InputMaybe<Scalars['String']['input']>;
  altHasSuffix?: InputMaybe<Scalars['String']['input']>;
  altIn?: InputMaybe<Array<Scalars['String']['input']>>;
  altIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  altLT?: InputMaybe<Scalars['String']['input']>;
  altLTE?: InputMaybe<Scalars['String']['input']>;
  altNEQ?: InputMaybe<Scalars['String']['input']>;
  altNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  altNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  and?: InputMaybe<Array<MediaWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** filename field predicates */
  filename?: InputMaybe<Scalars['String']['input']>;
  filenameContains?: InputMaybe<Scalars['String']['input']>;
  filenameContainsFold?: InputMaybe<Scalars['String']['input']>;
  filenameEqualFold?: InputMaybe<Scalars['String']['input']>;
  filenameGT?: InputMaybe<Scalars['String']['input']>;
  filenameGTE?: InputMaybe<Scalars['String']['input']>;
  filenameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  filenameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  filenameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  filenameIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  filenameLT?: InputMaybe<Scalars['String']['input']>;
  filenameLTE?: InputMaybe<Scalars['String']['input']>;
  filenameNEQ?: InputMaybe<Scalars['String']['input']>;
  filenameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  filenameNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<MediaWhereInput>;
  or?: InputMaybe<Array<MediaWhereInput>>;
  /** thumbnail_url field predicates */
  thumbnailURL?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLContains?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLGT?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLGTE?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  thumbnailURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  thumbnailURLLT?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLLTE?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLNEQ?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  thumbnailURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** url field predicates */
  url?: InputMaybe<Scalars['String']['input']>;
  urlContains?: InputMaybe<Scalars['String']['input']>;
  urlContainsFold?: InputMaybe<Scalars['String']['input']>;
  urlEqualFold?: InputMaybe<Scalars['String']['input']>;
  urlGT?: InputMaybe<Scalars['String']['input']>;
  urlGTE?: InputMaybe<Scalars['String']['input']>;
  urlHasPrefix?: InputMaybe<Scalars['String']['input']>;
  urlHasSuffix?: InputMaybe<Scalars['String']['input']>;
  urlIn?: InputMaybe<Array<Scalars['String']['input']>>;
  urlIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  urlLT?: InputMaybe<Scalars['String']['input']>;
  urlLTE?: InputMaybe<Scalars['String']['input']>;
  urlNEQ?: InputMaybe<Scalars['String']['input']>;
  urlNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  urlNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  createCommunity: Community;
  createPost: Post;
  host: Host;
  loginUser: LoginUserResponse;
  logoutUser: LogoutUserResponse;
  post: Post;
  registerUser: RegisterUserResponse;
  resendUserVerifyEmail: ResendVerifyEmailResponse;
  uploadMedia: Media;
  userRefreshToken: RefreshTokenResponse;
  userVerifyEmail: VerifyEmailResponse;
};


export type MutationCreateCommunityArgs = {
  input: CreateCommunityInput;
};


export type MutationCreatePostArgs = {
  input: CreatePostInput;
};


export type MutationHostArgs = {
  input: UpdateHostInput;
};


export type MutationLoginUserArgs = {
  input: LoginUserInput;
};


export type MutationPostArgs = {
  input: UpdatePostInput;
};


export type MutationRegisterUserArgs = {
  input: RegisterUserInput;
};


export type MutationResendUserVerifyEmailArgs = {
  input: ResendVerifyEmailInput;
};


export type MutationUploadMediaArgs = {
  dir?: InputMaybe<Scalars['String']['input']>;
  file: Scalars['Upload']['input'];
};


export type MutationUserVerifyEmailArgs = {
  input: VerifyEmailInput;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID']['output'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type Post = Node & {
  __typename?: 'Post';
  author: User;
  authorID: Scalars['ID']['output'];
  bookmarks?: Maybe<Array<Bookmark>>;
  comments?: Maybe<Array<Comment>>;
  community: Community;
  communityID: Scalars['ID']['output'];
  content: Scalars['JSON']['output'];
  createdAt: Scalars['Time']['output'];
  heroImage?: Maybe<Media>;
  heroImageID?: Maybe<Scalars['ID']['output']>;
  id: Scalars['ID']['output'];
  likes?: Maybe<Array<PostLike>>;
  publishedAt?: Maybe<Scalars['Time']['output']>;
  relatedPost?: Maybe<Array<Post>>;
  slug: Scalars['String']['output'];
  status: PostStatus;
  title: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
  viewerPermissions: CommunityPermissions;
};

export type PostLike = Node & {
  __typename?: 'PostLike';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  post: Post;
  postID: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
  user: User;
  userID: Scalars['ID']['output'];
};

/**
 * PostLikeWhereInput is used for filtering PostLike objects.
 * Input was generated by ent.
 */
export type PostLikeWhereInput = {
  and?: InputMaybe<Array<PostLikeWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<PostLikeWhereInput>;
  or?: InputMaybe<Array<PostLikeWhereInput>>;
  /** post_id field predicates */
  postID?: InputMaybe<Scalars['ID']['input']>;
  postIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  postIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  postIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** PostStatus is enum for the field status */
export enum PostStatus {
  Deleted = 'deleted',
  Draft = 'draft',
  Published = 'published'
}

/**
 * PostWhereInput is used for filtering Post objects.
 * Input was generated by ent.
 */
export type PostWhereInput = {
  and?: InputMaybe<Array<PostWhereInput>>;
  /** author_id field predicates */
  authorID?: InputMaybe<Scalars['ID']['input']>;
  authorIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  authorIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  authorIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** community_id field predicates */
  communityID?: InputMaybe<Scalars['ID']['input']>;
  communityIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  communityIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  communityIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** author edge predicates */
  hasAuthor?: InputMaybe<Scalars['Boolean']['input']>;
  hasAuthorWith?: InputMaybe<Array<UserWhereInput>>;
  /** bookmarks edge predicates */
  hasBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  hasBookmarksWith?: InputMaybe<Array<BookmarkWhereInput>>;
  /** comments edge predicates */
  hasComments?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommentsWith?: InputMaybe<Array<CommentWhereInput>>;
  /** community edge predicates */
  hasCommunity?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommunityWith?: InputMaybe<Array<CommunityWhereInput>>;
  /** hero_image edge predicates */
  hasHeroImage?: InputMaybe<Scalars['Boolean']['input']>;
  hasHeroImageWith?: InputMaybe<Array<MediaWhereInput>>;
  /** likes edge predicates */
  hasLikes?: InputMaybe<Scalars['Boolean']['input']>;
  hasLikesWith?: InputMaybe<Array<PostLikeWhereInput>>;
  /** related_post edge predicates */
  hasRelatedPost?: InputMaybe<Scalars['Boolean']['input']>;
  hasRelatedPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** hero_image_id field predicates */
  heroImageID?: InputMaybe<Scalars['ID']['input']>;
  heroImageIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  heroImageIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  heroImageIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  heroImageIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  heroImageIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<PostWhereInput>;
  or?: InputMaybe<Array<PostWhereInput>>;
  /** published_at field predicates */
  publishedAt?: InputMaybe<Scalars['Time']['input']>;
  publishedAtGT?: InputMaybe<Scalars['Time']['input']>;
  publishedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  publishedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  publishedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  publishedAtLT?: InputMaybe<Scalars['Time']['input']>;
  publishedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  publishedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  publishedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  publishedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** slug field predicates */
  slug?: InputMaybe<Scalars['String']['input']>;
  slugContains?: InputMaybe<Scalars['String']['input']>;
  slugContainsFold?: InputMaybe<Scalars['String']['input']>;
  slugEqualFold?: InputMaybe<Scalars['String']['input']>;
  slugGT?: InputMaybe<Scalars['String']['input']>;
  slugGTE?: InputMaybe<Scalars['String']['input']>;
  slugHasPrefix?: InputMaybe<Scalars['String']['input']>;
  slugHasSuffix?: InputMaybe<Scalars['String']['input']>;
  slugIn?: InputMaybe<Array<Scalars['String']['input']>>;
  slugLT?: InputMaybe<Scalars['String']['input']>;
  slugLTE?: InputMaybe<Scalars['String']['input']>;
  slugNEQ?: InputMaybe<Scalars['String']['input']>;
  slugNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** status field predicates */
  status?: InputMaybe<PostStatus>;
  statusIn?: InputMaybe<Array<PostStatus>>;
  statusNEQ?: InputMaybe<PostStatus>;
  statusNotIn?: InputMaybe<Array<PostStatus>>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type ProfileTableInfoItem = Node & {
  __typename?: 'ProfileTableInfoItem';
  community?: Maybe<Community>;
  communityID?: Maybe<Scalars['ID']['output']>;
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  type: ProfileTableInfoItemType;
  updatedAt: Scalars['Time']['output'];
  user?: Maybe<User>;
  userID?: Maybe<Scalars['ID']['output']>;
  value: Scalars['String']['output'];
};

/** ProfileTableInfoItemType is enum for the field type */
export enum ProfileTableInfoItemType {
  Community = 'community',
  User = 'user'
}

/**
 * ProfileTableInfoItemWhereInput is used for filtering ProfileTableInfoItem objects.
 * Input was generated by ent.
 */
export type ProfileTableInfoItemWhereInput = {
  and?: InputMaybe<Array<ProfileTableInfoItemWhereInput>>;
  /** community_id field predicates */
  communityID?: InputMaybe<Scalars['ID']['input']>;
  communityIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  communityIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  communityIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  communityIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  communityIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** community edge predicates */
  hasCommunity?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommunityWith?: InputMaybe<Array<CommunityWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** key field predicates */
  key?: InputMaybe<Scalars['String']['input']>;
  keyContains?: InputMaybe<Scalars['String']['input']>;
  keyContainsFold?: InputMaybe<Scalars['String']['input']>;
  keyEqualFold?: InputMaybe<Scalars['String']['input']>;
  keyGT?: InputMaybe<Scalars['String']['input']>;
  keyGTE?: InputMaybe<Scalars['String']['input']>;
  keyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  keyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  keyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  keyLT?: InputMaybe<Scalars['String']['input']>;
  keyLTE?: InputMaybe<Scalars['String']['input']>;
  keyNEQ?: InputMaybe<Scalars['String']['input']>;
  keyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<ProfileTableInfoItemWhereInput>;
  or?: InputMaybe<Array<ProfileTableInfoItemWhereInput>>;
  /** type field predicates */
  type?: InputMaybe<ProfileTableInfoItemType>;
  typeIn?: InputMaybe<Array<ProfileTableInfoItemType>>;
  typeNEQ?: InputMaybe<ProfileTableInfoItemType>;
  typeNotIn?: InputMaybe<Array<ProfileTableInfoItemType>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** value field predicates */
  value?: InputMaybe<Scalars['String']['input']>;
  valueContains?: InputMaybe<Scalars['String']['input']>;
  valueContainsFold?: InputMaybe<Scalars['String']['input']>;
  valueEqualFold?: InputMaybe<Scalars['String']['input']>;
  valueGT?: InputMaybe<Scalars['String']['input']>;
  valueGTE?: InputMaybe<Scalars['String']['input']>;
  valueHasPrefix?: InputMaybe<Scalars['String']['input']>;
  valueHasSuffix?: InputMaybe<Scalars['String']['input']>;
  valueIn?: InputMaybe<Array<Scalars['String']['input']>>;
  valueLT?: InputMaybe<Scalars['String']['input']>;
  valueLTE?: InputMaybe<Scalars['String']['input']>;
  valueNEQ?: InputMaybe<Scalars['String']['input']>;
  valueNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type Query = {
  __typename?: 'Query';
  communities: Array<Community>;
  community?: Maybe<Community>;
  communityUserBan?: Maybe<CommunityUserBan>;
  communityUserMute?: Maybe<CommunityUserMute>;
  getMe: UserResponse;
  host?: Maybe<Host>;
  hostRole?: Maybe<HostRole>;
  hostRoles: Array<HostRole>;
  hostSidebarNavigation?: Maybe<HostSidebarNavigation>;
  hostSidebarNavigationItems: Array<HostSidebarNavigationItem>;
  hostSocialNavigation?: Maybe<HostSocialNavigation>;
  hostUserBan?: Maybe<HostUserBan>;
  hostUsersBan: Array<HostUserBan>;
  media?: Maybe<Media>;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  post?: Maybe<Post>;
  posts: Array<Post>;
  profileTableInfoItem?: Maybe<ProfileTableInfoItem>;
  profileTableInfoItems: Array<ProfileTableInfoItem>;
  role?: Maybe<Role>;
  roles: Array<Role>;
  user?: Maybe<User>;
  users: Array<User>;
};


export type QueryCommunitiesArgs = {
  onlyNotBanned?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryCommunityArgs = {
  id: Scalars['ID']['input'];
};


export type QueryCommunityUserBanArgs = {
  communityId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};


export type QueryCommunityUserMuteArgs = {
  communityId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};


export type QueryHostRoleArgs = {
  id: Scalars['ID']['input'];
};


export type QueryHostUserBanArgs = {
  id: Scalars['ID']['input'];
};


export type QueryMediaArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type QueryPostArgs = {
  id: Scalars['ID']['input'];
};


export type QueryPostsArgs = {
  status?: InputMaybe<PostStatus>;
};


export type QueryProfileTableInfoItemArgs = {
  id: Scalars['ID']['input'];
};


export type QueryProfileTableInfoItemsArgs = {
  id: Scalars['ID']['input'];
  type: ProfileTableInfoItemType;
};


export type QueryRoleArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRolesArgs = {
  id: Scalars['ID']['input'];
};


export type QueryUserArgs = {
  id: Scalars['ID']['input'];
};

export type RefreshTokenResponse = {
  __typename?: 'RefreshTokenResponse';
  accessToken: Scalars['String']['output'];
  refreshToken: Scalars['String']['output'];
};

export type RegisterUserInput = {
  email: Scalars['String']['input'];
  name: Scalars['String']['input'];
  password: Scalars['String']['input'];
};

export type RegisterUserResponse = {
  __typename?: 'RegisterUserResponse';
  message: Scalars['String']['output'];
};

export type ResendVerifyEmailInput = {
  email: Scalars['String']['input'];
};

export type ResendVerifyEmailResponse = {
  __typename?: 'ResendVerifyEmailResponse';
  message: Scalars['String']['output'];
};

export type Role = Node & {
  __typename?: 'Role';
  badge?: Maybe<Media>;
  badgeID?: Maybe<Scalars['ID']['output']>;
  color?: Maybe<Scalars['String']['output']>;
  community: Community;
  communityDeleteComments: Scalars['Boolean']['output'];
  communityDeletePost: Scalars['Boolean']['output'];
  communityID: Scalars['ID']['output'];
  communityRemovePostFromPublication: Scalars['Boolean']['output'];
  communityRolesManagement: Scalars['Boolean']['output'];
  communityUserBan: Scalars['Boolean']['output'];
  communityUserMute: Scalars['Boolean']['output'];
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  title: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
  users?: Maybe<Array<User>>;
};

/**
 * RoleWhereInput is used for filtering Role objects.
 * Input was generated by ent.
 */
export type RoleWhereInput = {
  and?: InputMaybe<Array<RoleWhereInput>>;
  /** badge_id field predicates */
  badgeID?: InputMaybe<Scalars['ID']['input']>;
  badgeIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  badgeIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  badgeIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  badgeIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  badgeIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** color field predicates */
  color?: InputMaybe<Scalars['String']['input']>;
  colorContains?: InputMaybe<Scalars['String']['input']>;
  colorContainsFold?: InputMaybe<Scalars['String']['input']>;
  colorEqualFold?: InputMaybe<Scalars['String']['input']>;
  colorGT?: InputMaybe<Scalars['String']['input']>;
  colorGTE?: InputMaybe<Scalars['String']['input']>;
  colorHasPrefix?: InputMaybe<Scalars['String']['input']>;
  colorHasSuffix?: InputMaybe<Scalars['String']['input']>;
  colorIn?: InputMaybe<Array<Scalars['String']['input']>>;
  colorIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  colorLT?: InputMaybe<Scalars['String']['input']>;
  colorLTE?: InputMaybe<Scalars['String']['input']>;
  colorNEQ?: InputMaybe<Scalars['String']['input']>;
  colorNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  colorNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** community_delete_comments field predicates */
  communityDeleteComments?: InputMaybe<Scalars['Boolean']['input']>;
  communityDeleteCommentsNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** community_delete_post field predicates */
  communityDeletePost?: InputMaybe<Scalars['Boolean']['input']>;
  communityDeletePostNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** community_id field predicates */
  communityID?: InputMaybe<Scalars['ID']['input']>;
  communityIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  communityIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  communityIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** community_remove_post_from_publication field predicates */
  communityRemovePostFromPublication?: InputMaybe<Scalars['Boolean']['input']>;
  communityRemovePostFromPublicationNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** community_roles_management field predicates */
  communityRolesManagement?: InputMaybe<Scalars['Boolean']['input']>;
  communityRolesManagementNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** community_user_ban field predicates */
  communityUserBan?: InputMaybe<Scalars['Boolean']['input']>;
  communityUserBanNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** community_user_mute field predicates */
  communityUserMute?: InputMaybe<Scalars['Boolean']['input']>;
  communityUserMuteNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** badge edge predicates */
  hasBadge?: InputMaybe<Scalars['Boolean']['input']>;
  hasBadgeWith?: InputMaybe<Array<MediaWhereInput>>;
  /** community edge predicates */
  hasCommunity?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommunityWith?: InputMaybe<Array<CommunityWhereInput>>;
  /** users edge predicates */
  hasUsers?: InputMaybe<Scalars['Boolean']['input']>;
  hasUsersWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<RoleWhereInput>;
  or?: InputMaybe<Array<RoleWhereInput>>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type UpdateHostInput = {
  authBannerID?: InputMaybe<Scalars['ID']['input']>;
  bannerID?: InputMaybe<Scalars['ID']['input']>;
  contacts?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  firstSettings?: InputMaybe<Scalars['Boolean']['input']>;
  logoID?: InputMaybe<Scalars['ID']['input']>;
  slogan?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type UpdatePostInput = {
  communityID?: InputMaybe<Scalars['ID']['input']>;
  content?: InputMaybe<Scalars['JSON']['input']>;
  heroImageID?: InputMaybe<Scalars['ID']['input']>;
  id: Scalars['ID']['input'];
  publishedAt?: InputMaybe<Scalars['Time']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<PostStatus>;
  title?: InputMaybe<Scalars['String']['input']>;
  views?: InputMaybe<Scalars['Int']['input']>;
};

export type User = Node & {
  __typename?: 'User';
  avatar?: Maybe<Media>;
  avatarID?: Maybe<Scalars['ID']['output']>;
  banner?: Maybe<Media>;
  bannerID?: Maybe<Scalars['ID']['output']>;
  bookmarks?: Maybe<Array<Bookmark>>;
  comments?: Maybe<Array<Comment>>;
  commentsLikes?: Maybe<Array<CommentLike>>;
  communitiesBans?: Maybe<Array<CommunityUserBan>>;
  communitiesFollow?: Maybe<Array<CommunityFollow>>;
  communitiesModerator?: Maybe<Array<CommunityModerator>>;
  communitiesMutes?: Maybe<Array<CommunityUserMute>>;
  communitiesOwner?: Maybe<Array<Community>>;
  communitiesRoles?: Maybe<Array<Role>>;
  createdAt: Scalars['Time']['output'];
  description?: Maybe<Scalars['String']['output']>;
  email: Scalars['String']['output'];
  emailVerifications?: Maybe<Array<EmailVerification>>;
  followers?: Maybe<Array<UserFollow>>;
  following?: Maybe<Array<UserFollow>>;
  hostRoles?: Maybe<Array<HostRole>>;
  id: Scalars['ID']['output'];
  isVerified: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  passwordHash: Scalars['String']['output'];
  posts?: Maybe<Array<Post>>;
  postsLikes?: Maybe<Array<PostLike>>;
  salt: Scalars['String']['output'];
  slug: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
  userInfo?: Maybe<Array<ProfileTableInfoItem>>;
};

export type UserAvatarResponse = {
  __typename?: 'UserAvatarResponse';
  id: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

export type UserCommunityRoleResponse = {
  __typename?: 'UserCommunityRoleResponse';
  color: Scalars['String']['output'];
  communityDeleteComments: Scalars['Boolean']['output'];
  communityDeletePost: Scalars['Boolean']['output'];
  communityRemovePostFromPublication: Scalars['Boolean']['output'];
  communityRolesManagement: Scalars['Boolean']['output'];
  communityUserBan: Scalars['Boolean']['output'];
  communityUserMute: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  title: Scalars['String']['output'];
};

export type UserFollow = Node & {
  __typename?: 'UserFollow';
  createdAt: Scalars['Time']['output'];
  followee: User;
  followeeID: Scalars['ID']['output'];
  follower: User;
  followerID: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
};

/**
 * UserFollowWhereInput is used for filtering UserFollow objects.
 * Input was generated by ent.
 */
export type UserFollowWhereInput = {
  and?: InputMaybe<Array<UserFollowWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** followee_id field predicates */
  followeeID?: InputMaybe<Scalars['ID']['input']>;
  followeeIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  followeeIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  followeeIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** follower_id field predicates */
  followerID?: InputMaybe<Scalars['ID']['input']>;
  followerIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  followerIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  followerIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** followee edge predicates */
  hasFollowee?: InputMaybe<Scalars['Boolean']['input']>;
  hasFolloweeWith?: InputMaybe<Array<UserWhereInput>>;
  /** follower edge predicates */
  hasFollower?: InputMaybe<Scalars['Boolean']['input']>;
  hasFollowerWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<UserFollowWhereInput>;
  or?: InputMaybe<Array<UserFollowWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type UserHostRoleResponse = {
  __typename?: 'UserHostRoleResponse';
  color: Scalars['String']['output'];
  communityRolesManagement: Scalars['Boolean']['output'];
  hostCommunityDeleteComments: Scalars['Boolean']['output'];
  hostCommunityDeletePost: Scalars['Boolean']['output'];
  hostCommunityRemovePostFromPublication: Scalars['Boolean']['output'];
  hostUserBan: Scalars['Boolean']['output'];
  hostUserMute: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  title: Scalars['String']['output'];
};

export type UserInfoResponse = {
  __typename?: 'UserInfoResponse';
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type UserResponse = {
  __typename?: 'UserResponse';
  avatar?: Maybe<UserAvatarResponse>;
  communitiesRoles: Array<UserCommunityRoleResponse>;
  createdAt: Scalars['String']['output'];
  description: Scalars['String']['output'];
  email: Scalars['String']['output'];
  hostRoles: Array<UserHostRoleResponse>;
  id: Scalars['ID']['output'];
  isVerified: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  slug: Scalars['String']['output'];
  updatedAt: Scalars['String']['output'];
  userInfo: Array<UserInfoResponse>;
};

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** avatar_id field predicates */
  avatarID?: InputMaybe<Scalars['ID']['input']>;
  avatarIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  avatarIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  avatarIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  avatarIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  avatarIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** banner_id field predicates */
  bannerID?: InputMaybe<Scalars['ID']['input']>;
  bannerIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  bannerIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  bannerIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  bannerIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  bannerIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']['input']>;
  emailContains?: InputMaybe<Scalars['String']['input']>;
  emailContainsFold?: InputMaybe<Scalars['String']['input']>;
  emailEqualFold?: InputMaybe<Scalars['String']['input']>;
  emailGT?: InputMaybe<Scalars['String']['input']>;
  emailGTE?: InputMaybe<Scalars['String']['input']>;
  emailHasPrefix?: InputMaybe<Scalars['String']['input']>;
  emailHasSuffix?: InputMaybe<Scalars['String']['input']>;
  emailIn?: InputMaybe<Array<Scalars['String']['input']>>;
  emailLT?: InputMaybe<Scalars['String']['input']>;
  emailLTE?: InputMaybe<Scalars['String']['input']>;
  emailNEQ?: InputMaybe<Scalars['String']['input']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** avatar edge predicates */
  hasAvatar?: InputMaybe<Scalars['Boolean']['input']>;
  hasAvatarWith?: InputMaybe<Array<MediaWhereInput>>;
  /** banner edge predicates */
  hasBanner?: InputMaybe<Scalars['Boolean']['input']>;
  hasBannerWith?: InputMaybe<Array<MediaWhereInput>>;
  /** bookmarks edge predicates */
  hasBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  hasBookmarksWith?: InputMaybe<Array<BookmarkWhereInput>>;
  /** comments edge predicates */
  hasComments?: InputMaybe<Scalars['Boolean']['input']>;
  /** comments_likes edge predicates */
  hasCommentsLikes?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommentsLikesWith?: InputMaybe<Array<CommentLikeWhereInput>>;
  hasCommentsWith?: InputMaybe<Array<CommentWhereInput>>;
  /** communities_bans edge predicates */
  hasCommunitiesBans?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommunitiesBansWith?: InputMaybe<Array<CommunityUserBanWhereInput>>;
  /** communities_follow edge predicates */
  hasCommunitiesFollow?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommunitiesFollowWith?: InputMaybe<Array<CommunityFollowWhereInput>>;
  /** communities_moderator edge predicates */
  hasCommunitiesModerator?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommunitiesModeratorWith?: InputMaybe<Array<CommunityModeratorWhereInput>>;
  /** communities_mutes edge predicates */
  hasCommunitiesMutes?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommunitiesMutesWith?: InputMaybe<Array<CommunityUserMuteWhereInput>>;
  /** communities_owner edge predicates */
  hasCommunitiesOwner?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommunitiesOwnerWith?: InputMaybe<Array<CommunityWhereInput>>;
  /** communities_roles edge predicates */
  hasCommunitiesRoles?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommunitiesRolesWith?: InputMaybe<Array<RoleWhereInput>>;
  /** email_verifications edge predicates */
  hasEmailVerifications?: InputMaybe<Scalars['Boolean']['input']>;
  hasEmailVerificationsWith?: InputMaybe<Array<EmailVerificationWhereInput>>;
  /** followers edge predicates */
  hasFollowers?: InputMaybe<Scalars['Boolean']['input']>;
  hasFollowersWith?: InputMaybe<Array<UserFollowWhereInput>>;
  /** following edge predicates */
  hasFollowing?: InputMaybe<Scalars['Boolean']['input']>;
  hasFollowingWith?: InputMaybe<Array<UserFollowWhereInput>>;
  /** host_roles edge predicates */
  hasHostRoles?: InputMaybe<Scalars['Boolean']['input']>;
  hasHostRolesWith?: InputMaybe<Array<HostRoleWhereInput>>;
  /** posts edge predicates */
  hasPosts?: InputMaybe<Scalars['Boolean']['input']>;
  /** posts_likes edge predicates */
  hasPostsLikes?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostsLikesWith?: InputMaybe<Array<PostLikeWhereInput>>;
  hasPostsWith?: InputMaybe<Array<PostWhereInput>>;
  /** user_info edge predicates */
  hasUserInfo?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserInfoWith?: InputMaybe<Array<ProfileTableInfoItemWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** is_verified field predicates */
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  isVerifiedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
  /** password_hash field predicates */
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  passwordHashContains?: InputMaybe<Scalars['String']['input']>;
  passwordHashContainsFold?: InputMaybe<Scalars['String']['input']>;
  passwordHashEqualFold?: InputMaybe<Scalars['String']['input']>;
  passwordHashGT?: InputMaybe<Scalars['String']['input']>;
  passwordHashGTE?: InputMaybe<Scalars['String']['input']>;
  passwordHashHasPrefix?: InputMaybe<Scalars['String']['input']>;
  passwordHashHasSuffix?: InputMaybe<Scalars['String']['input']>;
  passwordHashIn?: InputMaybe<Array<Scalars['String']['input']>>;
  passwordHashLT?: InputMaybe<Scalars['String']['input']>;
  passwordHashLTE?: InputMaybe<Scalars['String']['input']>;
  passwordHashNEQ?: InputMaybe<Scalars['String']['input']>;
  passwordHashNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** salt field predicates */
  salt?: InputMaybe<Scalars['String']['input']>;
  saltContains?: InputMaybe<Scalars['String']['input']>;
  saltContainsFold?: InputMaybe<Scalars['String']['input']>;
  saltEqualFold?: InputMaybe<Scalars['String']['input']>;
  saltGT?: InputMaybe<Scalars['String']['input']>;
  saltGTE?: InputMaybe<Scalars['String']['input']>;
  saltHasPrefix?: InputMaybe<Scalars['String']['input']>;
  saltHasSuffix?: InputMaybe<Scalars['String']['input']>;
  saltIn?: InputMaybe<Array<Scalars['String']['input']>>;
  saltLT?: InputMaybe<Scalars['String']['input']>;
  saltLTE?: InputMaybe<Scalars['String']['input']>;
  saltNEQ?: InputMaybe<Scalars['String']['input']>;
  saltNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** slug field predicates */
  slug?: InputMaybe<Scalars['String']['input']>;
  slugContains?: InputMaybe<Scalars['String']['input']>;
  slugContainsFold?: InputMaybe<Scalars['String']['input']>;
  slugEqualFold?: InputMaybe<Scalars['String']['input']>;
  slugGT?: InputMaybe<Scalars['String']['input']>;
  slugGTE?: InputMaybe<Scalars['String']['input']>;
  slugHasPrefix?: InputMaybe<Scalars['String']['input']>;
  slugHasSuffix?: InputMaybe<Scalars['String']['input']>;
  slugIn?: InputMaybe<Array<Scalars['String']['input']>>;
  slugLT?: InputMaybe<Scalars['String']['input']>;
  slugLTE?: InputMaybe<Scalars['String']['input']>;
  slugNEQ?: InputMaybe<Scalars['String']['input']>;
  slugNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type VerifyEmailInput = {
  token: Scalars['String']['input'];
};

export type VerifyEmailResponse = {
  __typename?: 'VerifyEmailResponse';
  message: Scalars['String']['output'];
};

export type GetHostSidebarNavigationQueryVariables = Types.Exact<{ [key: string]: never; }>;


export type GetHostSidebarNavigationQuery = { __typename?: 'Query', hostSidebarNavigation?: { __typename?: 'HostSidebarNavigation', items?: Array<{ __typename?: 'HostSidebarNavigationItem', id: string, createdAt: any, post: { __typename?: 'Post', id: string, title: string } }> | null } | null };


export const GetHostSidebarNavigationDocument = gql`
    query GetHostSidebarNavigation {
  hostSidebarNavigation {
    items {
      id
      post {
        id
        title
      }
      createdAt
    }
  }
}
    `;

/**
 * __useGetHostSidebarNavigationQuery__
 *
 * To run a query within a React component, call `useGetHostSidebarNavigationQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetHostSidebarNavigationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetHostSidebarNavigationQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetHostSidebarNavigationQuery(baseOptions?: Apollo.QueryHookOptions<GetHostSidebarNavigationQuery, GetHostSidebarNavigationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetHostSidebarNavigationQuery, GetHostSidebarNavigationQueryVariables>(GetHostSidebarNavigationDocument, options);
      }
export function useGetHostSidebarNavigationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetHostSidebarNavigationQuery, GetHostSidebarNavigationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetHostSidebarNavigationQuery, GetHostSidebarNavigationQueryVariables>(GetHostSidebarNavigationDocument, options);
        }
export function useGetHostSidebarNavigationSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetHostSidebarNavigationQuery, GetHostSidebarNavigationQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetHostSidebarNavigationQuery, GetHostSidebarNavigationQueryVariables>(GetHostSidebarNavigationDocument, options);
        }
export type GetHostSidebarNavigationQueryHookResult = ReturnType<typeof useGetHostSidebarNavigationQuery>;
export type GetHostSidebarNavigationLazyQueryHookResult = ReturnType<typeof useGetHostSidebarNavigationLazyQuery>;
export type GetHostSidebarNavigationSuspenseQueryHookResult = ReturnType<typeof useGetHostSidebarNavigationSuspenseQuery>;
export type GetHostSidebarNavigationQueryResult = Apollo.QueryResult<GetHostSidebarNavigationQuery, GetHostSidebarNavigationQueryVariables>;